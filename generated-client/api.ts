/* tslint:disable */
/* eslint-disable */
/**
 * OpenApi specification - Replicator Service
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * Contact: engineering@trolet.ca
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AttributesDto
 */
export interface AttributesDto {
    /**
     * 
     * @type {string}
     * @memberof AttributesDto
     */
    'brand'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttributesDto
     */
    'model'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttributesDto
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttributesDto
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttributesDto
     */
    'usSize'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttributesDto
     */
    'euSize'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttributesDto
     */
    'cmSize'?: string;
    /**
     * 
     * @type {number}
     * @memberof AttributesDto
     */
    'originalPrice'?: number;
    /**
     * 
     * @type {string}
     * @memberof AttributesDto
     */
    'color'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttributesDto
     */
    'material'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttributesDto
     */
    'closure'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttributesDto
     */
    'shoeStyle'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttributesDto
     */
    'shoeShaftStyle'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttributesDto
     */
    'outsoleMaterial'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttributesDto
     */
    'pattern'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttributesDto
     */
    'brandSKU'?: string;
    /**
     * 
     * @type {string}
     * @memberof AttributesDto
     */
    'stdShoeWidth'?: string;
    /**
     * 
     * @type {number}
     * @memberof AttributesDto
     */
    'cmShoeWidth'?: number;
}
/**
 * 
 * @export
 * @interface CommentDto
 */
export interface CommentDto {
    /**
     * 
     * @type {string}
     * @memberof CommentDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentDto
     */
    'sender'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentDto
     */
    'timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof CommentDto
     */
    'content'?: string;
}
/**
 * 
 * @export
 * @interface EmployeeDto
 */
export interface EmployeeDto {
    /**
     * 
     * @type {string}
     * @memberof EmployeeDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmployeeDto
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmployeeDto
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmployeeDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmployeeDto
     */
    'picture'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmployeeDto
     */
    'customPicture'?: string;
    /**
     * 
     * @type {string}
     * @memberof EmployeeDto
     */
    'repairedFootwearCount'?: string;
}
/**
 * 
 * @export
 * @interface FootwearAttributeRangesDto
 */
export interface FootwearAttributeRangesDto {
    /**
     * 
     * @type {NumericRange}
     * @memberof FootwearAttributeRangesDto
     */
    'usSize'?: NumericRange;
    /**
     * 
     * @type {NumericRange}
     * @memberof FootwearAttributeRangesDto
     */
    'euSize'?: NumericRange;
    /**
     * 
     * @type {NumericRange}
     * @memberof FootwearAttributeRangesDto
     */
    'cmSize'?: NumericRange;
    /**
     * 
     * @type {NumericRange}
     * @memberof FootwearAttributeRangesDto
     */
    'cmShoeWidth'?: NumericRange;
    /**
     * 
     * @type {NumericRange}
     * @memberof FootwearAttributeRangesDto
     */
    'originalPrice'?: NumericRange;
}
/**
 * 
 * @export
 * @interface FootwearDto
 */
export interface FootwearDto {
    /**
     * 
     * @type {string}
     * @memberof FootwearDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FootwearDto
     */
    'quality'?: FootwearDtoQualityEnum;
    /**
     * 
     * @type {string}
     * @memberof FootwearDto
     */
    'condition'?: FootwearDtoConditionEnum;
    /**
     * 
     * @type {PhotoGroupDto}
     * @memberof FootwearDto
     */
    'photoGroup'?: PhotoGroupDto;
    /**
     * 
     * @type {boolean}
     * @memberof FootwearDto
     */
    'sizeVisible'?: boolean;
    /**
     * 
     * @type {ProceduresDto}
     * @memberof FootwearDto
     */
    'procedures'?: ProceduresDto;
    /**
     * 
     * @type {number}
     * @memberof FootwearDto
     */
    'currentStep'?: number;
    /**
     * 
     * @type {Array<number>}
     * @memberof FootwearDto
     */
    'stepHistory'?: Array<number>;
    /**
     * 
     * @type {Array<CommentDto>}
     * @memberof FootwearDto
     */
    'comments'?: Array<CommentDto>;
    /**
     * 
     * @type {Array<RepairDto>}
     * @memberof FootwearDto
     */
    'repairs'?: Array<RepairDto>;
    /**
     * 
     * @type {AttributesDto}
     * @memberof FootwearDto
     */
    'attributes'?: AttributesDto;
    /**
     * 
     * @type {string}
     * @memberof FootwearDto
     */
    'washMethod'?: FootwearDtoWashMethodEnum;
    /**
     * 
     * @type {string}
     * @memberof FootwearDto
     */
    'location'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FootwearDto
     */
    'archived'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FootwearDto
     */
    'backtracked'?: boolean;
    /**
     * 
     * @type {Array<StepDto>}
     * @memberof FootwearDto
     */
    'operationTime'?: Array<StepDto>;
}

export const FootwearDtoQualityEnum = {
    T1: 'T1',
    T2: 'T2'
} as const;

export type FootwearDtoQualityEnum = typeof FootwearDtoQualityEnum[keyof typeof FootwearDtoQualityEnum];
export const FootwearDtoConditionEnum = {
    None: 'None',
    New: 'New',
    LikeNew: 'Like New',
    VeryGood: 'Very Good',
    Good: 'Good',
    SmallRepair: 'Small Repair',
    MediumRepair: 'Medium Repair',
    LargeRepair: 'Large Repair'
} as const;

export type FootwearDtoConditionEnum = typeof FootwearDtoConditionEnum[keyof typeof FootwearDtoConditionEnum];
export const FootwearDtoWashMethodEnum = {
    BrushMachine: 'Brush Machine',
    HighPressure: 'High-Pressure',
    WashingMachine: 'Washing Machine',
    Insole: 'Insole'
} as const;

export type FootwearDtoWashMethodEnum = typeof FootwearDtoWashMethodEnum[keyof typeof FootwearDtoWashMethodEnum];

/**
 * 
 * @export
 * @interface FootwearFilterRequestDto
 */
export interface FootwearFilterRequestDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof FootwearFilterRequestDto
     */
    'quality'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FootwearFilterRequestDto
     */
    'condition'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FootwearFilterRequestDto
     */
    'currentStep'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FootwearFilterRequestDto
     */
    'sizeVisible'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FootwearFilterRequestDto
     */
    'washMethod'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FootwearFilterRequestDto
     */
    'brand'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FootwearFilterRequestDto
     */
    'model'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FootwearFilterRequestDto
     */
    'category'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FootwearFilterRequestDto
     */
    'type'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FootwearFilterRequestDto
     */
    'color'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FootwearFilterRequestDto
     */
    'material'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FootwearFilterRequestDto
     */
    'closure'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FootwearFilterRequestDto
     */
    'shoeStyle'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FootwearFilterRequestDto
     */
    'shoeShaftStyle'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FootwearFilterRequestDto
     */
    'outsoleMaterial'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FootwearFilterRequestDto
     */
    'pattern'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FootwearFilterRequestDto
     */
    'stdShoeWidth'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: NumericRange; }}
     * @memberof FootwearFilterRequestDto
     */
    'ranges'?: { [key: string]: NumericRange; };
    /**
     * 
     * @type {{ [key: string]: boolean; }}
     * @memberof FootwearFilterRequestDto
     */
    'numericFiltersEnabled'?: { [key: string]: boolean; };
    /**
     * 
     * @type {boolean}
     * @memberof FootwearFilterRequestDto
     */
    'showOnlyMissing'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof FootwearFilterRequestDto
     */
    'selectedSmallRepairs'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FootwearFilterRequestDto
     */
    'selectedMediumRepairs'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof FootwearFilterRequestDto
     */
    'selectedLargeRepairs'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof FootwearFilterRequestDto
     */
    'searchTerm'?: string;
}
/**
 * 
 * @export
 * @interface KindeUserDto
 */
export interface KindeUserDto {
    /**
     * 
     * @type {string}
     * @memberof KindeUserDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof KindeUserDto
     */
    'providedId'?: string;
    /**
     * 
     * @type {string}
     * @memberof KindeUserDto
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof KindeUserDto
     */
    'phone'?: string;
    /**
     * 
     * @type {string}
     * @memberof KindeUserDto
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof KindeUserDto
     */
    'first_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof KindeUserDto
     */
    'last_name'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof KindeUserDto
     */
    'is_suspended'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof KindeUserDto
     */
    'picture'?: string;
    /**
     * 
     * @type {string}
     * @memberof KindeUserDto
     */
    'custom_picture'?: string;
    /**
     * 
     * @type {number}
     * @memberof KindeUserDto
     */
    'total_sign_ins'?: number;
    /**
     * 
     * @type {number}
     * @memberof KindeUserDto
     */
    'failed_sign_ins'?: number;
    /**
     * 
     * @type {string}
     * @memberof KindeUserDto
     */
    'last_signed_in'?: string;
    /**
     * 
     * @type {string}
     * @memberof KindeUserDto
     */
    'created_on'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof KindeUserDto
     */
    'organizations'?: Array<string>;
    /**
     * 
     * @type {Array<UserIdentitiesInner>}
     * @memberof KindeUserDto
     */
    'identities'?: Array<UserIdentitiesInner>;
}
/**
 * 
 * @export
 * @interface NumericRange
 */
export interface NumericRange {
    /**
     * 
     * @type {number}
     * @memberof NumericRange
     */
    'min'?: number;
    /**
     * 
     * @type {number}
     * @memberof NumericRange
     */
    'max'?: number;
}
/**
 * Paginated response for DynamoDB data
 * @export
 * @interface PaginatedResponseDto
 */
export interface PaginatedResponseDto {
    /**
     * List of items for current page
     * @type {Array<FootwearDto>}
     * @memberof PaginatedResponseDto
     */
    'content'?: Array<FootwearDto>;
    /**
     * Token for next page (use as lastEvaluatedKey for next request)
     * @type {string}
     * @memberof PaginatedResponseDto
     */
    'nextPageToken'?: string;
    /**
     * Whether there are more results available
     * @type {boolean}
     * @memberof PaginatedResponseDto
     */
    'hasMoreResults'?: boolean;
    /**
     * Number of items returned in current page
     * @type {number}
     * @memberof PaginatedResponseDto
     */
    'pageSize'?: number;
    /**
     * Total number of items across all pages
     * @type {number}
     * @memberof PaginatedResponseDto
     */
    'totalElements'?: number;
}
/**
 * 
 * @export
 * @interface PhotoGroupDto
 */
export interface PhotoGroupDto {
    /**
     * 
     * @type {Array<string>}
     * @memberof PhotoGroupDto
     */
    'virtualAssistant'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PhotoGroupDto
     */
    'repairPhotos'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PhotoGroupDto
     */
    'postRepairPhotos'?: Array<string>;
}
/**
 * 
 * @export
 * @interface ProceduresDto
 */
export interface ProceduresDto {
    /**
     * 
     * @type {boolean}
     * @memberof ProceduresDto
     */
    'vacuumed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProceduresDto
     */
    'disinfected'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProceduresDto
     */
    'fiberRemoved'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProceduresDto
     */
    'lintRemoved'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProceduresDto
     */
    'wiped'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProceduresDto
     */
    'washed'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProceduresDto
     */
    'dried'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProceduresDto
     */
    'packaged'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ProceduresDto
     */
    'rfidWritten'?: boolean;
}
/**
 * 
 * @export
 * @interface ProductDto
 */
export interface ProductDto {
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'category'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'handle'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductDto
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'color'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'colorMetaobject'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'size'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'sizeMetaobject'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'footwearMaterialMetaobject'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'genderMetaobject'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'descriptionHtml'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'descriptionMetafield'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'definitionEtat'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'condition'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'dimensions'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof ProductDto
     */
    'medias'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'price'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'compareAtPrice'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'sku'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductDto
     */
    'location'?: string;
}
/**
 * 
 * @export
 * @interface RepairDto
 */
export interface RepairDto {
    /**
     * 
     * @type {number}
     * @memberof RepairDto
     */
    'id'?: number;
    /**
     * 
     * @type {string}
     * @memberof RepairDto
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RepairDto
     */
    'category'?: RepairDtoCategoryEnum;
    /**
     * 
     * @type {boolean}
     * @memberof RepairDto
     */
    'selected'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RepairDto
     */
    'requiresRest'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof RepairDto
     */
    'status'?: RepairDtoStatusEnum;
    /**
     * 
     * @type {number}
     * @memberof RepairDto
     */
    'repairTime'?: number;
    /**
     * 
     * @type {number}
     * @memberof RepairDto
     */
    'restTime'?: number;
    /**
     * 
     * @type {number}
     * @memberof RepairDto
     */
    'repairStartTime'?: number;
    /**
     * 
     * @type {number}
     * @memberof RepairDto
     */
    'restStartTime'?: number;
}

export const RepairDtoCategoryEnum = {
    None: 'NONE',
    Small: 'SMALL',
    Medium: 'MEDIUM',
    Large: 'LARGE'
} as const;

export type RepairDtoCategoryEnum = typeof RepairDtoCategoryEnum[keyof typeof RepairDtoCategoryEnum];
export const RepairDtoStatusEnum = {
    NotStarted: 'NOT_STARTED',
    Repairing: 'REPAIRING',
    Resting: 'RESTING',
    Finished: 'FINISHED'
} as const;

export type RepairDtoStatusEnum = typeof RepairDtoStatusEnum[keyof typeof RepairDtoStatusEnum];

/**
 * 
 * @export
 * @interface StepDto
 */
export interface StepDto {
    /**
     * 
     * @type {number}
     * @memberof StepDto
     */
    'currStep'?: number;
    /**
     * 
     * @type {number}
     * @memberof StepDto
     */
    'duration'?: number;
    /**
     * 
     * @type {string}
     * @memberof StepDto
     */
    'start'?: string;
    /**
     * 
     * @type {string}
     * @memberof StepDto
     */
    'end'?: string;
}
/**
 * 
 * @export
 * @interface SuccessResponse
 */
export interface SuccessResponse {
    /**
     * 
     * @type {string}
     * @memberof SuccessResponse
     */
    'message'?: string;
    /**
     * 
     * @type {string}
     * @memberof SuccessResponse
     */
    'code'?: string;
}
/**
 * 
 * @export
 * @interface UploadFootwearImageRequest
 */
export interface UploadFootwearImageRequest {
    /**
     * 
     * @type {File}
     * @memberof UploadFootwearImageRequest
     */
    'file': File;
}
/**
 * 
 * @export
 * @interface UserIdentitiesInner
 */
export interface UserIdentitiesInner {
    /**
     * 
     * @type {string}
     * @memberof UserIdentitiesInner
     */
    'type'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserIdentitiesInner
     */
    'identity'?: string;
}

/**
 * EmployeeControllerApi - axios parameter creator
 * @export
 */
export const EmployeeControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new employee
         * @param {EmployeeDto} employeeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmployee: async (employeeDto: EmployeeDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'employeeDto' is not null or undefined
            assertParamExists('createEmployee', 'employeeDto', employeeDto)
            const localVarPath = `/employee/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(employeeDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an employee
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmployee: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteEmployee', 'id', id)
            const localVarPath = `/employee/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete an employee from DynamoDB only
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmployeeFromDynamoDBOnly: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteEmployeeFromDynamoDBOnly', 'id', id)
            const localVarPath = `/employee/{id}/dynamodb-only`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if employee exists in DynamoDB by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeExistsInDynamoDB: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('employeeExistsInDynamoDB', 'id', id)
            const localVarPath = `/employee/{id}/exists`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all employees
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEmployees: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/employee/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get an employee by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmployee: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getEmployee', 'id', id)
            const localVarPath = `/employee/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Partially update an existing employee
         * @param {string} id 
         * @param {EmployeeDto} employeeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmployee: async (id: string, employeeDto: EmployeeDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateEmployee', 'id', id)
            // verify required parameter 'employeeDto' is not null or undefined
            assertParamExists('updateEmployee', 'employeeDto', employeeDto)
            const localVarPath = `/employee/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(employeeDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmployeeControllerApi - functional programming interface
 * @export
 */
export const EmployeeControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EmployeeControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new employee
         * @param {EmployeeDto} employeeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createEmployee(employeeDto: EmployeeDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createEmployee(employeeDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmployeeControllerApi.createEmployee']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an employee
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEmployee(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEmployee(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmployeeControllerApi.deleteEmployee']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete an employee from DynamoDB only
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteEmployeeFromDynamoDBOnly(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteEmployeeFromDynamoDBOnly(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmployeeControllerApi.deleteEmployeeFromDynamoDBOnly']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check if employee exists in DynamoDB by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async employeeExistsInDynamoDB(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.employeeExistsInDynamoDB(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmployeeControllerApi.employeeExistsInDynamoDB']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all employees
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllEmployees(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EmployeeDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllEmployees(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmployeeControllerApi.getAllEmployees']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get an employee by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getEmployee(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EmployeeDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getEmployee(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmployeeControllerApi.getEmployee']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Partially update an existing employee
         * @param {string} id 
         * @param {EmployeeDto} employeeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateEmployee(id: string, employeeDto: EmployeeDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateEmployee(id, employeeDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['EmployeeControllerApi.updateEmployee']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * EmployeeControllerApi - factory interface
 * @export
 */
export const EmployeeControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EmployeeControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new employee
         * @param {EmployeeDto} employeeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createEmployee(employeeDto: EmployeeDto, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.createEmployee(employeeDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an employee
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmployee(id: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.deleteEmployee(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete an employee from DynamoDB only
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmployeeFromDynamoDBOnly(id: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.deleteEmployeeFromDynamoDBOnly(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if employee exists in DynamoDB by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        employeeExistsInDynamoDB(id: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.employeeExistsInDynamoDB(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all employees
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllEmployees(options?: RawAxiosRequestConfig): AxiosPromise<Array<EmployeeDto>> {
            return localVarFp.getAllEmployees(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get an employee by ID
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmployee(id: string, options?: RawAxiosRequestConfig): AxiosPromise<EmployeeDto> {
            return localVarFp.getEmployee(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Partially update an existing employee
         * @param {string} id 
         * @param {EmployeeDto} employeeDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmployee(id: string, employeeDto: EmployeeDto, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.updateEmployee(id, employeeDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EmployeeControllerApi - object-oriented interface
 * @export
 * @class EmployeeControllerApi
 * @extends {BaseAPI}
 */
export class EmployeeControllerApi extends BaseAPI {
    /**
     * 
     * @summary Create a new employee
     * @param {EmployeeDto} employeeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeControllerApi
     */
    public createEmployee(employeeDto: EmployeeDto, options?: RawAxiosRequestConfig) {
        return EmployeeControllerApiFp(this.configuration).createEmployee(employeeDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an employee
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeControllerApi
     */
    public deleteEmployee(id: string, options?: RawAxiosRequestConfig) {
        return EmployeeControllerApiFp(this.configuration).deleteEmployee(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete an employee from DynamoDB only
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeControllerApi
     */
    public deleteEmployeeFromDynamoDBOnly(id: string, options?: RawAxiosRequestConfig) {
        return EmployeeControllerApiFp(this.configuration).deleteEmployeeFromDynamoDBOnly(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if employee exists in DynamoDB by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeControllerApi
     */
    public employeeExistsInDynamoDB(id: string, options?: RawAxiosRequestConfig) {
        return EmployeeControllerApiFp(this.configuration).employeeExistsInDynamoDB(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all employees
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeControllerApi
     */
    public getAllEmployees(options?: RawAxiosRequestConfig) {
        return EmployeeControllerApiFp(this.configuration).getAllEmployees(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get an employee by ID
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeControllerApi
     */
    public getEmployee(id: string, options?: RawAxiosRequestConfig) {
        return EmployeeControllerApiFp(this.configuration).getEmployee(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Partially update an existing employee
     * @param {string} id 
     * @param {EmployeeDto} employeeDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmployeeControllerApi
     */
    public updateEmployee(id: string, employeeDto: EmployeeDto, options?: RawAxiosRequestConfig) {
        return EmployeeControllerApiFp(this.configuration).updateEmployee(id, employeeDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FootwearControllerApi - axios parameter creator
 * @export
 */
export const FootwearControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new footwear
         * @param {FootwearDto} footwearDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFootwear: async (footwearDto: FootwearDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'footwearDto' is not null or undefined
            assertParamExists('createFootwear', 'footwearDto', footwearDto)
            const localVarPath = `/footwear/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(footwearDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a footwear and associated files
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFootwear: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteFootwear', 'id', id)
            const localVarPath = `/footwear/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete footwear image in B2 bucket
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFootwearImage: async (fileName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('deleteFootwearImage', 'fileName', fileName)
            const localVarPath = `/footwear/files/{fileName}`
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete a specific photo from footwear photo group by filename in DynamoDB
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePhotoFromDatabase: async (fileName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('deletePhotoFromDatabase', 'fileName', fileName)
            const localVarPath = `/footwear/files/{fileName}/database`
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all footwears with file URLs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFootwears: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/footwear/all`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all footwears with file URLs (paginated)
         * @param {number} [size] Number of items per page
         * @param {string} [sortBy] Sort field
         * @param {string} [sortDir] Sort direction
         * @param {string} [nextPageToken] Token for next page
         * @param {FootwearFilterRequestDto} [footwearFilterRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFootwearsFilteredPaginated: async (size?: number, sortBy?: string, sortDir?: string, nextPageToken?: string, footwearFilterRequestDto?: FootwearFilterRequestDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/footwear/all/paginated/filtered`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (size !== undefined) {
                localVarQueryParameter['size'] = size;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sortDir'] = sortDir;
            }

            if (nextPageToken !== undefined) {
                localVarQueryParameter['nextPageToken'] = nextPageToken;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(footwearFilterRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get file (serve actual image)
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile: async (fileName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getFile', 'fileName', fileName)
            const localVarPath = `/footwear/files/{fileName}`
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get file info
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileInfo: async (fileName: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'fileName' is not null or undefined
            assertParamExists('getFileInfo', 'fileName', fileName)
            const localVarPath = `/footwear/files/{fileName}/info`
                .replace(`{${"fileName"}}`, encodeURIComponent(String(fileName)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a footwear by ID with file URLs
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFootwear: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getFootwear', 'id', id)
            const localVarPath = `/footwear/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get min/max ranges for numeric footwear attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFootwearAttributeRanges: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/footwear/attributes/ranges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all taken footwear locations. Returns only the location strings that are currently in use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTakenLocations: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/footwear/locations/taken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get count of taken locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTakenLocationsCount: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/footwear/locations/taken/count`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify if a specific location is taken
         * @param {string} location 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isLocationTaken: async (location: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'location' is not null or undefined
            assertParamExists('isLocationTaken', 'location', location)
            const localVarPath = `/footwear/locations/taken/check/{location}`
                .replace(`{${"location"}}`, encodeURIComponent(String(location)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update footwear data (DynamoDB)
         * @param {string} id 
         * @param {FootwearDto} footwearDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFootwearData: async (id: string, footwearDto: FootwearDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFootwearData', 'id', id)
            // verify required parameter 'footwearDto' is not null or undefined
            assertParamExists('updateFootwearData', 'footwearDto', footwearDto)
            const localVarPath = `/footwear/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(footwearDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update footwear files (B2)
         * @param {string} id 
         * @param {string} [footwear] 
         * @param {Array<File>} [virtualAssistantPhotos] 
         * @param {Array<File>} [repairPhotos] 
         * @param {Array<File>} [postRepairPhotos] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFootwearFiles: async (id: string, footwear?: string, virtualAssistantPhotos?: Array<File>, repairPhotos?: Array<File>, postRepairPhotos?: Array<File>, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateFootwearFiles', 'id', id)
            const localVarPath = `/footwear/{id}/files`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new ((configuration && configuration.formDataCtor) || FormData)();

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


            if (footwear !== undefined) { 
                localVarFormParams.append('footwear', footwear as any);
            }
                if (virtualAssistantPhotos) {
                virtualAssistantPhotos.forEach((element) => {
                    localVarFormParams.append('virtualAssistantPhotos', element as any);
                })
            }

                if (repairPhotos) {
                repairPhotos.forEach((element) => {
                    localVarFormParams.append('repairPhotos', element as any);
                })
            }

                if (postRepairPhotos) {
                postRepairPhotos.forEach((element) => {
                    localVarFormParams.append('postRepairPhotos', element as any);
                })
            }

    
    
            localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams;

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Upload footwear image
         * @param {UploadFootwearImageRequest} [uploadFootwearImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFootwearImage: async (uploadFootwearImageRequest?: UploadFootwearImageRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/footwear/files`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(uploadFootwearImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FootwearControllerApi - functional programming interface
 * @export
 */
export const FootwearControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FootwearControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new footwear
         * @param {FootwearDto} footwearDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createFootwear(footwearDto: FootwearDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createFootwear(footwearDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FootwearControllerApi.createFootwear']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a footwear and associated files
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFootwear(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFootwear(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FootwearControllerApi.deleteFootwear']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete footwear image in B2 bucket
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteFootwearImage(fileName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteFootwearImage(fileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FootwearControllerApi.deleteFootwearImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Delete a specific photo from footwear photo group by filename in DynamoDB
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePhotoFromDatabase(fileName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePhotoFromDatabase(fileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FootwearControllerApi.deletePhotoFromDatabase']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all footwears with file URLs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllFootwears(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FootwearDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllFootwears(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FootwearControllerApi.getAllFootwears']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all footwears with file URLs (paginated)
         * @param {number} [size] Number of items per page
         * @param {string} [sortBy] Sort field
         * @param {string} [sortDir] Sort direction
         * @param {string} [nextPageToken] Token for next page
         * @param {FootwearFilterRequestDto} [footwearFilterRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllFootwearsFilteredPaginated(size?: number, sortBy?: string, sortDir?: string, nextPageToken?: string, footwearFilterRequestDto?: FootwearFilterRequestDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PaginatedResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllFootwearsFilteredPaginated(size, sortBy, sortDir, nextPageToken, footwearFilterRequestDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FootwearControllerApi.getAllFootwearsFilteredPaginated']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get file (serve actual image)
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFile(fileName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<File>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFile(fileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FootwearControllerApi.getFile']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get file info
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFileInfo(fileName: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFileInfo(fileName, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FootwearControllerApi.getFileInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get a footwear by ID with file URLs
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFootwear(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FootwearDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFootwear(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FootwearControllerApi.getFootwear']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get min/max ranges for numeric footwear attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFootwearAttributeRanges(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FootwearAttributeRangesDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFootwearAttributeRanges(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FootwearControllerApi.getFootwearAttributeRanges']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all taken footwear locations. Returns only the location strings that are currently in use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTakenLocations(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTakenLocations(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FootwearControllerApi.getTakenLocations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get count of taken locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTakenLocationsCount(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTakenLocationsCount(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FootwearControllerApi.getTakenLocationsCount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Verify if a specific location is taken
         * @param {string} location 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async isLocationTaken(location: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.isLocationTaken(location, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FootwearControllerApi.isLocationTaken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update footwear data (DynamoDB)
         * @param {string} id 
         * @param {FootwearDto} footwearDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFootwearData(id: string, footwearDto: FootwearDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFootwearData(id, footwearDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FootwearControllerApi.updateFootwearData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update footwear files (B2)
         * @param {string} id 
         * @param {string} [footwear] 
         * @param {Array<File>} [virtualAssistantPhotos] 
         * @param {Array<File>} [repairPhotos] 
         * @param {Array<File>} [postRepairPhotos] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateFootwearFiles(id: string, footwear?: string, virtualAssistantPhotos?: Array<File>, repairPhotos?: Array<File>, postRepairPhotos?: Array<File>, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateFootwearFiles(id, footwear, virtualAssistantPhotos, repairPhotos, postRepairPhotos, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FootwearControllerApi.updateFootwearFiles']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Upload footwear image
         * @param {UploadFootwearImageRequest} [uploadFootwearImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async uploadFootwearImage(uploadFootwearImageRequest?: UploadFootwearImageRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.uploadFootwearImage(uploadFootwearImageRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FootwearControllerApi.uploadFootwearImage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FootwearControllerApi - factory interface
 * @export
 */
export const FootwearControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FootwearControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new footwear
         * @param {FootwearDto} footwearDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createFootwear(footwearDto: FootwearDto, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.createFootwear(footwearDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a footwear and associated files
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFootwear(id: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.deleteFootwear(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete footwear image in B2 bucket
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFootwearImage(fileName: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.deleteFootwearImage(fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete a specific photo from footwear photo group by filename in DynamoDB
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePhotoFromDatabase(fileName: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.deletePhotoFromDatabase(fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all footwears with file URLs
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFootwears(options?: RawAxiosRequestConfig): AxiosPromise<Array<FootwearDto>> {
            return localVarFp.getAllFootwears(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all footwears with file URLs (paginated)
         * @param {number} [size] Number of items per page
         * @param {string} [sortBy] Sort field
         * @param {string} [sortDir] Sort direction
         * @param {string} [nextPageToken] Token for next page
         * @param {FootwearFilterRequestDto} [footwearFilterRequestDto] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllFootwearsFilteredPaginated(size?: number, sortBy?: string, sortDir?: string, nextPageToken?: string, footwearFilterRequestDto?: FootwearFilterRequestDto, options?: RawAxiosRequestConfig): AxiosPromise<PaginatedResponseDto> {
            return localVarFp.getAllFootwearsFilteredPaginated(size, sortBy, sortDir, nextPageToken, footwearFilterRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get file (serve actual image)
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFile(fileName: string, options?: RawAxiosRequestConfig): AxiosPromise<File> {
            return localVarFp.getFile(fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get file info
         * @param {string} fileName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFileInfo(fileName: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getFileInfo(fileName, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get a footwear by ID with file URLs
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFootwear(id: string, options?: RawAxiosRequestConfig): AxiosPromise<FootwearDto> {
            return localVarFp.getFootwear(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get min/max ranges for numeric footwear attributes
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFootwearAttributeRanges(options?: RawAxiosRequestConfig): AxiosPromise<FootwearAttributeRangesDto> {
            return localVarFp.getFootwearAttributeRanges(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all taken footwear locations. Returns only the location strings that are currently in use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTakenLocations(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getTakenLocations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get count of taken locations
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTakenLocationsCount(options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.getTakenLocationsCount(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify if a specific location is taken
         * @param {string} location 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        isLocationTaken(location: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.isLocationTaken(location, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update footwear data (DynamoDB)
         * @param {string} id 
         * @param {FootwearDto} footwearDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFootwearData(id: string, footwearDto: FootwearDto, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.updateFootwearData(id, footwearDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update footwear files (B2)
         * @param {string} id 
         * @param {string} [footwear] 
         * @param {Array<File>} [virtualAssistantPhotos] 
         * @param {Array<File>} [repairPhotos] 
         * @param {Array<File>} [postRepairPhotos] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFootwearFiles(id: string, footwear?: string, virtualAssistantPhotos?: Array<File>, repairPhotos?: Array<File>, postRepairPhotos?: Array<File>, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.updateFootwearFiles(id, footwear, virtualAssistantPhotos, repairPhotos, postRepairPhotos, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Upload footwear image
         * @param {UploadFootwearImageRequest} [uploadFootwearImageRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        uploadFootwearImage(uploadFootwearImageRequest?: UploadFootwearImageRequest, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.uploadFootwearImage(uploadFootwearImageRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FootwearControllerApi - object-oriented interface
 * @export
 * @class FootwearControllerApi
 * @extends {BaseAPI}
 */
export class FootwearControllerApi extends BaseAPI {
    /**
     * 
     * @summary Create a new footwear
     * @param {FootwearDto} footwearDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FootwearControllerApi
     */
    public createFootwear(footwearDto: FootwearDto, options?: RawAxiosRequestConfig) {
        return FootwearControllerApiFp(this.configuration).createFootwear(footwearDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a footwear and associated files
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FootwearControllerApi
     */
    public deleteFootwear(id: string, options?: RawAxiosRequestConfig) {
        return FootwearControllerApiFp(this.configuration).deleteFootwear(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete footwear image in B2 bucket
     * @param {string} fileName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FootwearControllerApi
     */
    public deleteFootwearImage(fileName: string, options?: RawAxiosRequestConfig) {
        return FootwearControllerApiFp(this.configuration).deleteFootwearImage(fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete a specific photo from footwear photo group by filename in DynamoDB
     * @param {string} fileName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FootwearControllerApi
     */
    public deletePhotoFromDatabase(fileName: string, options?: RawAxiosRequestConfig) {
        return FootwearControllerApiFp(this.configuration).deletePhotoFromDatabase(fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all footwears with file URLs
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FootwearControllerApi
     */
    public getAllFootwears(options?: RawAxiosRequestConfig) {
        return FootwearControllerApiFp(this.configuration).getAllFootwears(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all footwears with file URLs (paginated)
     * @param {number} [size] Number of items per page
     * @param {string} [sortBy] Sort field
     * @param {string} [sortDir] Sort direction
     * @param {string} [nextPageToken] Token for next page
     * @param {FootwearFilterRequestDto} [footwearFilterRequestDto] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FootwearControllerApi
     */
    public getAllFootwearsFilteredPaginated(size?: number, sortBy?: string, sortDir?: string, nextPageToken?: string, footwearFilterRequestDto?: FootwearFilterRequestDto, options?: RawAxiosRequestConfig) {
        return FootwearControllerApiFp(this.configuration).getAllFootwearsFilteredPaginated(size, sortBy, sortDir, nextPageToken, footwearFilterRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get file (serve actual image)
     * @param {string} fileName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FootwearControllerApi
     */
    public getFile(fileName: string, options?: RawAxiosRequestConfig) {
        return FootwearControllerApiFp(this.configuration).getFile(fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get file info
     * @param {string} fileName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FootwearControllerApi
     */
    public getFileInfo(fileName: string, options?: RawAxiosRequestConfig) {
        return FootwearControllerApiFp(this.configuration).getFileInfo(fileName, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get a footwear by ID with file URLs
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FootwearControllerApi
     */
    public getFootwear(id: string, options?: RawAxiosRequestConfig) {
        return FootwearControllerApiFp(this.configuration).getFootwear(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get min/max ranges for numeric footwear attributes
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FootwearControllerApi
     */
    public getFootwearAttributeRanges(options?: RawAxiosRequestConfig) {
        return FootwearControllerApiFp(this.configuration).getFootwearAttributeRanges(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all taken footwear locations. Returns only the location strings that are currently in use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FootwearControllerApi
     */
    public getTakenLocations(options?: RawAxiosRequestConfig) {
        return FootwearControllerApiFp(this.configuration).getTakenLocations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get count of taken locations
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FootwearControllerApi
     */
    public getTakenLocationsCount(options?: RawAxiosRequestConfig) {
        return FootwearControllerApiFp(this.configuration).getTakenLocationsCount(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify if a specific location is taken
     * @param {string} location 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FootwearControllerApi
     */
    public isLocationTaken(location: string, options?: RawAxiosRequestConfig) {
        return FootwearControllerApiFp(this.configuration).isLocationTaken(location, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update footwear data (DynamoDB)
     * @param {string} id 
     * @param {FootwearDto} footwearDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FootwearControllerApi
     */
    public updateFootwearData(id: string, footwearDto: FootwearDto, options?: RawAxiosRequestConfig) {
        return FootwearControllerApiFp(this.configuration).updateFootwearData(id, footwearDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update footwear files (B2)
     * @param {string} id 
     * @param {string} [footwear] 
     * @param {Array<File>} [virtualAssistantPhotos] 
     * @param {Array<File>} [repairPhotos] 
     * @param {Array<File>} [postRepairPhotos] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FootwearControllerApi
     */
    public updateFootwearFiles(id: string, footwear?: string, virtualAssistantPhotos?: Array<File>, repairPhotos?: Array<File>, postRepairPhotos?: Array<File>, options?: RawAxiosRequestConfig) {
        return FootwearControllerApiFp(this.configuration).updateFootwearFiles(id, footwear, virtualAssistantPhotos, repairPhotos, postRepairPhotos, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Upload footwear image
     * @param {UploadFootwearImageRequest} [uploadFootwearImageRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FootwearControllerApi
     */
    public uploadFootwearImage(uploadFootwearImageRequest?: UploadFootwearImageRequest, options?: RawAxiosRequestConfig) {
        return FootwearControllerApiFp(this.configuration).uploadFootwearImage(uploadFootwearImageRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * KindeUsersControllerApi - axios parameter creator
 * @export
 */
export const KindeUsersControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Delete Kinde user by ID
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteUser', 'userId', userId)
            const localVarPath = `/kinde/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all Kinde users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/kinde/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Kinde user by ID
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('getUserById', 'userId', userId)
            const localVarPath = `/kinde/user/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Check if Kinde user exists by ID
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userExists: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('userExists', 'userId', userId)
            const localVarPath = `/kinde/user/{userId}/exists`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * KindeUsersControllerApi - functional programming interface
 * @export
 */
export const KindeUsersControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = KindeUsersControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Delete Kinde user by ID
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUser(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SuccessResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUser(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KindeUsersControllerApi.deleteUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get all Kinde users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<KindeUserDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KindeUsersControllerApi.getAllUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get Kinde user by ID
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserById(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<KindeUserDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserById(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KindeUsersControllerApi.getUserById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Check if Kinde user exists by ID
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async userExists(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<boolean>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.userExists(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['KindeUsersControllerApi.userExists']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * KindeUsersControllerApi - factory interface
 * @export
 */
export const KindeUsersControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = KindeUsersControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Delete Kinde user by ID
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUser(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<SuccessResponse> {
            return localVarFp.deleteUser(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all Kinde users
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(options?: RawAxiosRequestConfig): AxiosPromise<Array<KindeUserDto>> {
            return localVarFp.getAllUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Kinde user by ID
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserById(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<KindeUserDto> {
            return localVarFp.getUserById(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Check if Kinde user exists by ID
         * @param {string} userId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        userExists(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<boolean> {
            return localVarFp.userExists(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * KindeUsersControllerApi - object-oriented interface
 * @export
 * @class KindeUsersControllerApi
 * @extends {BaseAPI}
 */
export class KindeUsersControllerApi extends BaseAPI {
    /**
     * 
     * @summary Delete Kinde user by ID
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KindeUsersControllerApi
     */
    public deleteUser(userId: string, options?: RawAxiosRequestConfig) {
        return KindeUsersControllerApiFp(this.configuration).deleteUser(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all Kinde users
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KindeUsersControllerApi
     */
    public getAllUsers(options?: RawAxiosRequestConfig) {
        return KindeUsersControllerApiFp(this.configuration).getAllUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Kinde user by ID
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KindeUsersControllerApi
     */
    public getUserById(userId: string, options?: RawAxiosRequestConfig) {
        return KindeUsersControllerApiFp(this.configuration).getUserById(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Check if Kinde user exists by ID
     * @param {string} userId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof KindeUsersControllerApi
     */
    public userExists(userId: string, options?: RawAxiosRequestConfig) {
        return KindeUsersControllerApiFp(this.configuration).userExists(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProductControllerApi - axios parameter creator
 * @export
 */
export const ProductControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create a new Shopify product
         * @param {ProductDto} productDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct1: async (productDto: ProductDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productDto' is not null or undefined
            assertParamExists('createProduct1', 'productDto', productDto)
            const localVarPath = `/product/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update an existing Shopify product
         * @param {ProductDto} productDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct: async (productDto: ProductDto, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'productDto' is not null or undefined
            assertParamExists('updateProduct', 'productDto', productDto)
            const localVarPath = `/product/update`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(productDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductControllerApi - functional programming interface
 * @export
 */
export const ProductControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create a new Shopify product
         * @param {ProductDto} productDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProduct1(productDto: ProductDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProduct1(productDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductControllerApi.createProduct1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Update an existing Shopify product
         * @param {ProductDto} productDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateProduct(productDto: ProductDto, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateProduct(productDto, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ProductControllerApi.updateProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ProductControllerApi - factory interface
 * @export
 */
export const ProductControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Create a new Shopify product
         * @param {ProductDto} productDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct1(productDto: ProductDto, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.createProduct1(productDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update an existing Shopify product
         * @param {ProductDto} productDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateProduct(productDto: ProductDto, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.updateProduct(productDto, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductControllerApi - object-oriented interface
 * @export
 * @class ProductControllerApi
 * @extends {BaseAPI}
 */
export class ProductControllerApi extends BaseAPI {
    /**
     * 
     * @summary Create a new Shopify product
     * @param {ProductDto} productDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductControllerApi
     */
    public createProduct1(productDto: ProductDto, options?: RawAxiosRequestConfig) {
        return ProductControllerApiFp(this.configuration).createProduct1(productDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update an existing Shopify product
     * @param {ProductDto} productDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductControllerApi
     */
    public updateProduct(productDto: ProductDto, options?: RawAxiosRequestConfig) {
        return ProductControllerApiFp(this.configuration).updateProduct(productDto, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TestControllerApi - axios parameter creator
 * @export
 */
export const TestControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testCreate: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/testcreate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testCreateDynamoDb: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test-create-d`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testFetch: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/testfetch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testFetchDynamoDbDoesExist: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test-fetch-de`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testFetchDynamoDbDoesNotExist: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/test-fetch-d`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TestControllerApi - functional programming interface
 * @export
 */
export const TestControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TestControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async test(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.test(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestControllerApi.test']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testCreate(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testCreate(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestControllerApi.testCreate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testCreateDynamoDb(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testCreateDynamoDb(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestControllerApi.testCreateDynamoDb']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testFetch(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testFetch(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestControllerApi.testFetch']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testFetchDynamoDbDoesExist(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testFetchDynamoDbDoesExist(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestControllerApi.testFetchDynamoDbDoesExist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testFetchDynamoDbDoesNotExist(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testFetchDynamoDbDoesNotExist(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TestControllerApi.testFetchDynamoDbDoesNotExist']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TestControllerApi - factory interface
 * @export
 */
export const TestControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TestControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        test(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.test(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testCreate(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.testCreate(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testCreateDynamoDb(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.testCreateDynamoDb(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testFetch(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.testFetch(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testFetchDynamoDbDoesExist(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.testFetchDynamoDbDoesExist(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testFetchDynamoDbDoesNotExist(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.testFetchDynamoDbDoesNotExist(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TestControllerApi - object-oriented interface
 * @export
 * @class TestControllerApi
 * @extends {BaseAPI}
 */
export class TestControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestControllerApi
     */
    public test(options?: RawAxiosRequestConfig) {
        return TestControllerApiFp(this.configuration).test(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestControllerApi
     */
    public testCreate(options?: RawAxiosRequestConfig) {
        return TestControllerApiFp(this.configuration).testCreate(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestControllerApi
     */
    public testCreateDynamoDb(options?: RawAxiosRequestConfig) {
        return TestControllerApiFp(this.configuration).testCreateDynamoDb(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestControllerApi
     */
    public testFetch(options?: RawAxiosRequestConfig) {
        return TestControllerApiFp(this.configuration).testFetch(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestControllerApi
     */
    public testFetchDynamoDbDoesExist(options?: RawAxiosRequestConfig) {
        return TestControllerApiFp(this.configuration).testFetchDynamoDbDoesExist(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TestControllerApi
     */
    public testFetchDynamoDbDoesNotExist(options?: RawAxiosRequestConfig) {
        return TestControllerApiFp(this.configuration).testFetchDynamoDbDoesNotExist(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TokenControllerApi - axios parameter creator
 * @export
 */
export const TokenControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Rotates token value, to be called every month on the first.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rotate-key`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication BearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenControllerApi - functional programming interface
 * @export
 */
export const TokenControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokenControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Rotates token value, to be called every month on the first.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createProduct(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createProduct(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TokenControllerApi.createProduct']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TokenControllerApi - factory interface
 * @export
 */
export const TokenControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokenControllerApiFp(configuration)
    return {
        /**
         * 
         * @summary Rotates token value, to be called every month on the first.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createProduct(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.createProduct(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokenControllerApi - object-oriented interface
 * @export
 * @class TokenControllerApi
 * @extends {BaseAPI}
 */
export class TokenControllerApi extends BaseAPI {
    /**
     * 
     * @summary Rotates token value, to be called every month on the first.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenControllerApi
     */
    public createProduct(options?: RawAxiosRequestConfig) {
        return TokenControllerApiFp(this.configuration).createProduct(options).then((request) => request(this.axios, this.basePath));
    }
}



